import eval7import itertoolsfrom eval7 import Cardimport pandas as pdimport osfrom typing import Tuple, Dict, Listimport syssys.path.append('/Users/zacharydawson/artificial-intelligence/poker/zbot/src/structures')from src.structures.action import Actionfrom src.structures.stage import Stagefrom src.structures.player import PlayerMAX_EVAL_HS = 135004160 # royal flush of any suitAHEAD = 0BEHIND = 1TIE = 2class Decision(object):        def __init__(self, actual_outcome: Action, hole_cards: Tuple[Card, Card], communal_cards: List[Card],                 stage: Stage, dealer: bool, opp_last_action: Action,                 my_last_action: Action, opp_stack_committed_curr_phase: int,                 my_stack_committed_curr_phase: int, opp_num_raises_curr_phase: int,                 my_num_raises_curr_phase: int, opp_num_raises_total: int, my_num_raises_total: int):        self.actual_outcome = actual_outcome        self.hole_cards = hole_cards        self.communal_cards = communal_cards        self.stage = stage        self.dealer = dealer        hand = list(self.hole_cards) + communal_cards        eval7_strength = eval7.evaluate(hand)        self.hand_strength = eval7_strength / MAX_EVAL_HS # scales to between 0 and 1. Needed for P(win)        self.hand_rank = eval7.handtype(eval7_strength)        self.opp_last_action = opp_last_action        self.my_last_action = my_last_action        self.my_stack_committed_curr_phase = my_stack_committed_curr_phase        self.opp_stack_committed_curr_phase = opp_stack_committed_curr_phase        self.my_num_raises_curr_phase = my_num_raises_curr_phase        self.opp_num_raises_curr_phase = opp_num_raises_curr_phase        self.my_num_raises_total = my_num_raises_total        self.opp_num_raises_total = opp_num_raises_total        #self.ppot, self.npot = (0, 0) # cannot calculate in a reasonable amount of time        self.num_outs = self.calc_num_outs_one_card()        #self.ppot, self.npot = self.calc_hand_potential()        self.winning_prob = self.calc_win_prob()        self.highest_card, self.num_aces, self.num_kings, self.num_queens = self.analyze_board()    def calc_num_outs_one_card(self):        # no outs pre flop        if len(self.communal_cards) == 0:            return 0                # calculate outs after flop and turn        deck = eval7.Deck()        remaining_cards = list(set(deck.cards) - set(self.communal_cards) - set(self.hole_cards))        num_outs = 0        for card in remaining_cards:            hand = list(self.hole_cards) + self.communal_cards + [card]            hand_strength = eval7.evaluate(hand)            hand_rank = eval7.handtype(hand_strength)            if hand_strength > self.hand_strength and hand_rank != self.hand_rank:                num_outs+=1                        return num_outs        def calc_hand_potential(self):        # not tractable preflop. Too many card combinations. Not required at the river either        if len(self.communal_cards) == 0 or len(self.communal_cards) == 5:            return 0, 0                HP = [[0,0,0],[0,0,0],[0,0,0]] # W L T counter for each         HP_total = [0,0,0] # total W L T counter                deck = eval7.Deck()        remaining_cards = list(set(deck.cards) - set(self.communal_cards) - set(self.hole_cards))                our_hand = list(self.hole_cards) + self.communal_cards        our_hand_strength = eval7.evaluate(our_hand)        our_hand_rank = eval7.handtype(our_hand_strength)                opp_cards = itertools.combinations(remaining_cards, 2)                        for opponent_hand in opp_cards:            opponent_hand = list(opponent_hand) + self.communal_cards            opponent_hand_strength = eval7.evaluate(opponent_hand)            opponent_hand_rank = eval7.handtype(opponent_hand_strength)                        index = None                        if our_hand_rank == opponent_hand_rank: # tie                index = TIE            elif our_hand_strength > opponent_hand_strength: # win                 index = AHEAD            else: # loss                index = BEHIND                        HP_total[index] += 1                        new_remaining_cards = list(set(deck.cards) - set(self.communal_cards) - set(self.hole_cards) - set(opponent_hand))                        remaining_board = itertools.combinations(new_remaining_cards, 5 - len(self.communal_cards))                        for runout in remaining_board:                board = self.communal_cards + list(runout)                our_hand = list(self.hole_cards) + board                our_hand_strength = eval7.evaluate(our_hand)                our_hand_rank = eval7.handtype(our_hand_strength)                                opponent_hand = opponent_hand + board                opponent_hand_strength = eval7.evaluate(opponent_hand)                opponent_hand_rank = eval7.handtype(opponent_hand_strength)                                if our_hand_rank == opponent_hand_rank: # tie                    HP[index][TIE] += 1                elif our_hand_strength > opponent_hand_strength: # win                     HP[index][AHEAD] += 1                else: # loss                    HP[index][BEHIND] += 1                                    ppot =  (HP[BEHIND][AHEAD] + HP[BEHIND][TIE]/2 + HP[TIE][AHEAD]/2) / (HP_total[BEHIND]+HP_total[TIE]/2)        npot =  (HP[AHEAD][BEHIND] + HP[TIE][BEHIND]/2+ HP[AHEAD][TIE]/2) / (HP_total[AHEAD]+HP_total[TIE]/2)        return ppot, npot            def calc_win_prob(self):        if len(self.communal_cards) == 0:            pre_flop_fn = os.path.join('/Users/zacharydawson/artificial-intelligence/poker/data', 'pre_flop_hand_rank.csv')            pre_flop_df = pd.read_csv(pre_flop_fn, delim_whitespace=True)            pre_flop_df = pre_flop_df.set_index('Hole')                        card1 = str(self.hole_cards[0])[0]            card2 = str(self.hole_cards[1])[0]            hand = card1 + card2            try:                pre_flop_df.loc[hand, 'Wins'] + pre_flop_df.loc[hand, 'Ties'] * 0.5            except:                hand = card2 + card1                        if self.hole_cards[0].suit == self.hole_cards[1].suit:                hand += 's'                        return pre_flop_df.loc[hand, 'Wins'] + pre_flop_df.loc[hand, 'Ties'] * 0.5        else:            return self.num_outs * 2.1 # value of one out as a percentage                def analyze_board(self):        num_aces, num_kings, num_queens = 0, 0, 0        highest_card = self.communal_cards[0] if len(self.communal_cards) > 0 else None        for card in self.communal_cards:                        if card > highest_card:                highest_card = card                        if 'A' in str(card):                num_aces += 1            elif 'K' in str(card):                num_kings += 1            elif 'Q' in str(card):                num_queens += 1                return (highest_card, num_aces, num_kings, num_queens)        def __str__(self):     return ""